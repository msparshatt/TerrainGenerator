// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ApplyTextures

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
RWTexture2D<float4> aoResult;
Texture2D<float4> heightMap;
Texture2DArray<float4> textures;
Texture2DArray<float4> aotextures;
int textureCount;
float factors[10];
int mixTypes[10];
float tiling;
int width;
int height;
int heightMapResolution;

float4 maxima[1000];
float4 minima[1000];

#define FUDGEFACTOR  0.05f  //
#define DIVISOR 0.1f

[numthreads(8,8,1)]
void ApplyTextures(uint3 id : SV_DispatchThreadID)
{
    int3 pos = int3((id.x * tiling) % width, (id.y * tiling) % height, 0);
    float4 pixelTexture = float4(textures[pos].x, textures[pos].y, textures[pos].z, 1.0);
    float4 pixelAO = float4(aotextures[pos].x, aotextures[pos].y, aotextures[pos].z, 1.0);
    float f = 0;

    int2 hmPos = int2((id.x * heightMapResolution) / width, (id.y * heightMapResolution) / height);
    float height = heightMap[hmPos].r * 2; //the red channel of the heightmap texture contains values between 0 and 0.5f

    for(int index = 1; index < textureCount; index ++) {
        float minValue = 1 - factors[index] - FUDGEFACTOR;
        float value = 0.0f;

        if(mixTypes[index] == 1) {                  //by height
            value = height;
        } else if (mixTypes[index] == 2) {          //by slope
            float minHeight = 10;
            float maxHeight = 0;

            for(int i = -1; i <= 1; i++) {
                for(int j = -1; j <= 1; j++) {

                    int2 newPos = int2(hmPos.x + i, hmPos.y + j);

                    height = heightMap[newPos].r * 2;

                    minHeight = min(minHeight, height);
                    maxHeight = max(maxHeight, height);
                }
            }

            value = ((maxHeight - minHeight) * 50);  //turn height difference into value between 0 & 1
        } else if(mixTypes[index] == 3) {           //peaks
            float minDistance = 1000;
            for(int index = 0; index < 1000; index++) {
                float4 maximum = maxima[index];
                if(maximum.x == -1) {
                    break;
                }

                float distance = (hmPos.x - maximum.x) * (hmPos.x - maximum.x) + (hmPos.y - maximum.y) * (hmPos.y - maximum.y);
                distance = sqrt(distance);
                minDistance = min(minDistance, distance);
            }

            value = 1 - minDistance / 100;
        } else if(mixTypes[index] == 4) {           //valleys
            float minDistance = 1000;
            for(int index = 0; index < 1000; index++) {
                float4 minimum = minima[index];
                if(minimum.x == -1) {
                    break;
                }


                float distance = (hmPos.x - minimum.x) * (hmPos.x - minimum.x) + (hmPos.y - minimum.y) * (hmPos.y - minimum.y);
                distance = sqrt(distance);
                minDistance = min(minDistance, distance);
            }            

            value = 1 - minDistance / 100;
        }

        f = (value - minValue) / DIVISOR;

        f = min(f, 1);
        f = max(f, 0);

        pos[2] = index;
        pixelTexture = pixelTexture * (1 - f) + float4(textures[pos].x, textures[pos].y, textures[pos].z, 1.0) * f;
        pixelAO = pixelAO * (1 - f) + float4(aotextures[pos].x, aotextures[pos].y, aotextures[pos].z, 1.0) * f;        
    }

    Result[id.xy] = pixelTexture;
    aoResult[id.xy] = pixelAO;
}