#include "noiseSimplex.cginc"
// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel GenerateTerrain

float PerlinScale;
float PerlinXOffset;
float PerlinYOffset;
int PerlinIterations;
int Resolution;

float VoronoiXOffset;
float VoronoiYOffset;
float CellSize;
int NumberCells;

float Factor;

float MinHeight;
float HeightScale;
bool ClampEdges;

RWBuffer<float> Heights;

float2 Rand2D(float xPos, float yPos)
{
    float2 smallValue = float2(sin(xPos), sin(yPos));

    float2 dotDir = float2(12.989f, 78.233f);
    float random = dot(smallValue, dotDir);

    float x = sin(random) * 143758.5453f;
    x -= floor(x);

    dotDir = float2(39.346f, 11.135f);
    random = dot(smallValue, dotDir);

    float y = sin(random) * 143758.5453f;
    y -= floor(y);

    return float2(x, y);
}

float VoronoiNoise(float xPos, float yPos)
{
    float xcoord = abs(xPos + VoronoiXOffset);
    float ycoord = abs(yPos + VoronoiYOffset);

    float xPosition = xcoord / CellSize;
    float yPosition = ycoord / CellSize;

    int xBase = floor(xPosition);
    int yBase = floor(yPosition);

    float minDistance = 100;
    float minDistance2 = 110;

    for(int x=-1; x<=1; x++) {
        for(int y=-1; y<=1; y++) {
            int cellX = xBase + x;
            int cellY = yBase + y;

            //don't try to read outside the bounds of the array
            if(cellX < 0) {
                continue;
            }
            if(cellY < 0) {
                continue;
            }

            float2 voronoiPos = float2(cellX, cellY) + Rand2D(cellX, cellY);
            float distToCell = sqrt((xPosition - voronoiPos.x) * (xPosition - voronoiPos.x) + (yPosition - voronoiPos.y) * (yPosition - voronoiPos.y));
            //Vector2.Distance(voronoiCells[cell.x, cell.y], pos);

            if(distToCell < minDistance){
                minDistance2 = minDistance;
                minDistance = distToCell;
            } else if(distToCell < minDistance2) {
                minDistance2 = distToCell;
            }   
        }
    }


    float result = 0;
    result = minDistance * -1 + minDistance2;

    return result;
}

[numthreads(8,8,1)]
void GenerateTerrain (uint3 id : SV_DispatchThreadID)
{
    float xCoord = PerlinXOffset + id.x;
    float yCoord = PerlinYOffset + id.y;
    float amplitude = 1.0;
    float scale = PerlinScale / 500.0;

    float perlin = 0;

    for(int i = 0; i < PerlinIterations; i++) {
        float value = snoise(float2(xCoord * scale + 0.1, yCoord * scale + 0.1));
        value = (value + 1) / 2;
        perlin += value / amplitude;

        scale *= 2;
        amplitude *= 2;
    }

    float voronoi = VoronoiNoise(id.x, id.y);

    int index = id.x + Resolution * id.y;
    float height = (voronoi * (1 - Factor) + perlin * Factor) * 0.7;

    float edgeClamp = 0;
    float center = Resolution / 2;
    if(ClampEdges) {

        float xDistance = id.x - center;
        float yDistance = id.y - center;
        float distance = xDistance * xDistance + yDistance * yDistance;

        edgeClamp = distance / (center * center);

        if(edgeClamp > 1) {
            edgeClamp = 1.0;
        }

        height = lerp(height, 0.5, edgeClamp);                    
    }

    if(height < MinHeight + 0.05) {
        if(height < MinHeight - 0.05) {
            height = MinHeight;                        
        } else {
            height = lerp(MinHeight, MinHeight + 0.05f, (height + 0.05f - MinHeight) * 10);
        }
    }

    height = (height - 0.5f) * HeightScale + 0.5f;

    Heights[index] = height;
}
